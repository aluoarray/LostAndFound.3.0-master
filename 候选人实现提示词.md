我希望可以在 home 的页面中，在 头像的左边添加一个小按钮，文本为 ”我的"，点击可以显示我发布过的帖子

接下来我希望使用 Deepseek API 来实现候选人匹配功能

deepseek: sk-f6f4148d13bf46f287fc8805f3c3bd2f

我已经有API Key，我已经使用 setx DEESEEK_API_KEY "my_key" 将 API Key 设置在当前会话中，并使用 `Write-Output $env:DEESEEK_API_KEY` 验证通过

下面是 Deepseek 官网说明的调用 Deepseek API 的方法

### 首次调用 API

DeepSeek API 使用与 OpenAI 兼容的 API 格式，通过修改配置，您可以使用 OpenAI SDK 来访问 DeepSeek API，或使用与 OpenAI API 兼容的软件。

| PARAM      | VALUE                                                      |
| ---------- | ---------------------------------------------------------- |
| base_url * | `https://api.deepseek.com`                               |
| api_key    | apply for an[API key](https://platform.deepseek.com/api_keys) |

\* 出于与 OpenAI 兼容考虑，您也可以将 `base_url` 设置为 `https://api.deepseek.com/v1` 来使用，但注意，此处 `v1` 与模型版本无关。

\* **`deepseek-chat` 和 `deepseek-reasoner` 都已经升级为 DeepSeek-V3.2。**`deepseek-chat` 对应 DeepSeek-V3.2 的**非思考模式**，`deepseek-reasoner` 对应 DeepSeek-V3.2 的**思考模式**。

### 调用对话 API

在创建 API key 之后，你可以使用以下样例脚本的来访问 DeepSeek API。样例为非流式输出，您可以将 stream 设置为 true 来使用流式输出。

```python
# Please install OpenAI SDK first: `pip3 install openai`
import os
from openai import OpenAI

client = OpenAI(
    api_key=os.environ.get('DEEPSEEK_API_KEY'),
    base_url="https://api.deepseek.com")

response = client.chat.completions.create(
    model="deepseek-chat",
    messages=[
        {"role": "system", "content": "You are a helpful assistant"},
        {"role": "user", "content": "Hello"},
    ],
    stream=False
)

print(response.choices[0].message.content)
```

如果还需要我提供什么内容，请随时告诉我

### 下面是实现候选人匹配的总体策略

目标：用 DeepSeek 大模型实现“智能体”部分，满足“及格线”（主要走大模型型 + 多智能体 + 规则/搜索辅助的混合路线），快速上线可演示结果。主要思路如下：

1. 集成 DeepSeek（最小工作量）
   - 目的：把项目与 DeepSeek API 连接，能发送文本 prompt 并接收生成的结构化 JSON。
   - 输出：一个轻量的 API wrapper（例如 `ai/deepseek.py`），支持请求、重试与错误处理。
2. 实体抽取（Post → 结构化数据）
   - 用 DeepSeek 将帖子正文抽取成结构化字段（item_name、location、time、color、特征等）。
   - 先做 Prompt engineering（样例 + few-shot），并加入本地缓存（模型返回会被存储到 DB 表 `ExtractionCache`）。
3. 候选检索（规则/搜索 Agent）
   - 通过规则/关键词/文本相似度（例如基于简单 TF-IDF 或句向量余弦）从“Found”与“Lost”帖子中检索 top-K 候选。
   - 这是第一个 Agent（Search Agent）。
4. 重新排序 & 决策（DeepSeek Agent）
   - 将 top-K 候选与目标帖的结构化数据一起发给 DeepSeek 进行核对与打分/排序（第二个 Agent）。
   - 结果返回置信度与匹配理由（便于人工复核与标注）。
5. 人工复核与标注（Admin UI）
   - 在 Admin 加入“匹配审核”页面：显示候选、置信度、接受/拒绝按钮。人工结果用于建立训练集。
6. 简易 ML 模型（可选，按需）
   - 收集到足够标注后训练轻量ML分类器（例如随机森林或小型神经网络），目标达到 ≥80% 准确率以满足“机器学习型”要求（如果能收集到足够数据）。
7. 结果缓存与微调（可选）
   - 将 DeepSeek 的好结果缓存并可用作后续 few-shot 实例，或进行 LoRA 微调（如可用）。
8. 最终交付
   - 文档、示例脚本、在 admin 的操作说明、演示视频/截图（可选）。

### 候选人匹配需要实现的功能作用

#### 概述 ✨

**候选人匹配（CandidateMatch）** 是把“可能对应的失物帖与招领帖”自动配对并记录下来的一层中间产物。它把检索器（TF‑IDF / token overlap）产出的候选与 LLM 重排序（[rerank_confidence](vscode-file://vscode-app/f:/Visual/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) / [rerank_reason](vscode-file://vscode-app/f:/Visual/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)）结合，供人工复核、通知用户或用于后续训练。

---

#### 对用户的价值（最终用户） ✅

- **更快找到匹配**：用户发布“丢失/拾到”信息后，系统能自动列出可能的匹配，减少用户翻找时间。
- **提示可信度**：显示 **置信度/理由**（LLM 生成）帮助用户判断匹配是否可信，决定是否联系对方。
- **减少错过机会**：当管理员或系统确认匹配后可以触发通知（可选），提高物品找回率。

---

#### 对开发者与运营的价值（开发者/管理员） 🔧

- **可审计的候选池**：每条候选都有 [score](vscode-file://vscode-app/f:/Visual/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) / [method](vscode-file://vscode-app/f:/Visual/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html) / 时间戳，方便追踪检索逻辑与调优效果。
- **人机协作流程**：保留人工复核点（[status](vscode-file://vscode-app/f:/Visual/Microsoft VS Code/resources/app/out/vs/code/electron-browser/workbench/workbench.html)：pending/accepted/rejected/reviewed），避免直接自动决策带来的风险。
- **数据闭环用于改进**：人工接受/拒绝的标签可积累成训练数据，用于训练更好的检索或分类模型（提升召回与精确率）。
- **节省成本**：把检索与 LLM 重排序分开（先检索，再有选择地调用 LLM），能更高效地使用 API 预算。

### 关于后台

* 这个项目的后台管理我们使用 Django 自带的后台
* Djangon 自带后台语言默认为英文，我们需要将其全部替换成英文
* 不只是如果，之后台后台添加的功能，请统一使用中文完成，并且 AI 生成的文本也需要使用中文

### 关于用户

* 对于新的帖子：当用户发出帖子后，应该自动进行候选者匹配，在用户帖子的下方，提供匹配度较高的帖子，并给出 智能体生成的 理由，以及需要跳转到对应帖子的按钮
* 对于旧的帖子：当有新的用户发出的帖子与这个旧的帖子匹配度很高的话，应该自动在这个旧的帖子下面的候选匹配列表中添加新的候选者帖子
* 通知：不论对于新发的帖子还是以前发过的帖子，一旦候选者匹配度达到非常高的程度，应该给用户发发送消息提醒用户，消息内容可以包含 AI 生成的理由，以及跳转到对应帖子的按钮。这个功能可以使用一个弹框来实现，或者你有更好的实现方法也可以。





## 候选人匹配行为流程

### 一、用户端流程

#### 1. 发布帖子

**code**

```
用户发布寻物/招领帖 
    ↓
系统自动触发匹配服务 (post_create → MatchingService.process_new_post)
    ↓
├── 实体抽取 (Extractor) → 保存到 ExtractionCache
├── 候选检索 (Searcher) → TF-IDF 找出相似帖子
├── LLM 重排序 (Ranker) → DeepSeek 打分并生成理由
└── 创建 CandidateMatch 记录 (status='pending')
    ↓
【注意】此时不会发送通知，需等待后台审核
```

#### 2. 查看帖子详情

**code**

```
用户访问帖子详情页
    ↓
系统查询该帖子的 CandidateMatch 记录
    ↓
显示"可能匹配的帖子"列表（按置信度排序，最多5条）
    ↓
用户可点击查看匹配帖子的详情
```

#### 3. 手动触发匹配

**code**

```
用户点击"触发匹配"/"重新匹配"按钮
    ↓
系统调用 MatchingService.trigger_matching
    ↓
重新执行匹配流程，更新 CandidateMatch 记录
```

#### 4. 查看通知

**code**

```
用户点击首页"🔔"通知按钮
    ↓
进入通知列表页，显示所有通知
    ↓
点击通知 → 标记为已读 → 跳转到匹配的帖子详情
```

---

### 二、后台管理员流程

#### 1. 查看候选匹配列表

**code**

```
管理员登录 /admin/ 后台
    ↓
进入"候选匹配"列表（按置信度降序排列）
    ↓
可查看：寻物帖、招领帖、匹配分数、LLM置信度、状态、匹配理由
```

#### 2. 审核匹配 - 接受

**code**

```
管理员选中匹配记录 → 点击"✅ 接受选中的匹配"
    ↓
CandidateMatch.status 更新为 'accepted'
CandidateMatch.reviewed_at 更新为当前时间
    ↓
【当前实现】仅更新状态，不自动发送通知
【可扩展】可在此触发通知发送给双方用户
```

#### 3. 审核匹配 - 拒绝

**code**

```
管理员选中匹配记录 → 点击"❌ 拒绝选中的匹配"
    ↓
CandidateMatch.status 更新为 'rejected'
CandidateMatch.reviewed_at 更新为当前时间
    ↓
该匹配不再显示给用户（可根据需求调整）
```

---

### 三、数据状态流转

**code**

```
CandidateMatch.status:
  
    pending (待审核) ──────→ accepted (已接受)
         │                        │
         │                        ↓
         │                   [可触发通知]
         │
         └─────────────────→ rejected (已拒绝)
                                  │
                                  ↓
                             [不显示给用户]
```

---

### 四、当前实现的不足与建议

| 问题         | 现状             | 建议改进                  |
| ------------ | ---------------- | ------------------------- |
| 通知发送时机 | 匹配创建时就发送 | 改为审核通过后发送        |
| 拒绝后的处理 | 仅更新状态       | 可从用户详情页隐藏        |
| 用户反馈     | 无               | 可让用户确认"是/不是我的" |

需要我实现"审核通过后才发送通知"的逻辑吗？

可以让审核后发送通知和自动发送通知共存，自动发送通知只有在匹配度极高时才出发(发消息表示这极有可能是你丢失/捡到的东西），比如匹配度达到 0.7 以上，而人工审查作为一个最终确认，用来做最终决定表示这就是你丢失/捡到的东西，或表示这两个帖子毫无关系，可以删除对应的匹配



好的，这个设计很合理。我来实现：

1. **自动通知** ：匹配度 ≥ 0.7 时自动发送"极有可能"的通知
2. **人工审核通知** ：管理员确认后发送"已确认"的通知
3. **拒绝操作** ：删除匹配记录

读取

matching_service.py**L1-End**

现在修改匹配服务，将阈值改为 0.7，并区分自动通知和人工审核通知：

**matching_service.py**(修改)**+9**-7

已修改

**matching_service.py**(修改)**+29**-4

已修改

现在修改 admin.py，让管理员接受时发送确认通知，拒绝时删除匹配记录：

**admin.py**(修改)**+24**-6

已修改

完成！现在的流程是：

---

## 更新后的行为流程

### 自动通知（匹配度 ≥ 70%）

**code**

```
系统匹配完成 → 置信度 ≥ 0.7
    ↓
自动发送通知：
  - 标题：🔥 极有可能是您丢失的物品！
  - 内容：高度匹配提示 + 匹配理由
```

### 人工审核 - 确认

**code**

```
管理员点击"✅ 确认匹配（通知用户）"
    ↓
├── 状态更新为 'accepted'
└── 发送确认通知：
      - 标题：✅ 已确认找到您的物品！
      - 内容：明确告知已确认，请联系对方
```

### 人工审核 - 拒绝

**code**

```
管理员点击"❌ 拒绝并删除匹配"
    ↓
├── 删除相关通知记录
└── 删除匹配记录（彻底清除）
```
